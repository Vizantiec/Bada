/* $Change: 1142016 $ */
//
// Copyright (c) 2011 Samsung Electronics Co., Ltd.
// All rights reserved.
 
// This software contains confidential and proprietary information 
// of Samsung Electronics Co., Ltd.
// The user of this software agrees not to disclose, disseminate or copy such 
// Confidential Information and shall use the software only in accordance with 
// the terms of the license agreement the user entered into with Samsung.
//
/** 
 * @file		FTextUtf8Decoder.h 
 * @brief		This is the header file for the %Utf8Decoder class.
 *
 * This header file contains the declarations of the %Utf8Decoder class.
 * 
 */
#ifndef _FTEXT_UTF8_DECODER_H_
#define _FTEXT_UTF8_DECODER_H_

// Includes
#include "FTextDecoder.h"

namespace Osp { namespace Text {

/**
 * @class	Utf8Decoder
 * @brief	This class is an implementation of the UTF-8 decoder.
 * @since	1.0
 *
 * The %Utf8Decoder class converts blocks of bytes into decoded blocks of characters. 
 * Universal Transformation Format-8 (UTF-8) is a translated language that is used on the internet. 
 * It converts the unicode into 8-bit bytes. 
 * UTF-8 encoding supports all unicode character values and surrogates. 
 *
 * For more information on the class features, see <a href="../com.osp.cppappprogramming.help/html/dev_guide/text/converting_text_data_separate_blocks.htm">Converting Text Data in Separate Blocks</a>.
 *
 * The following example demonstrates how to use the %Utf8Decoder class.

 *
 *	@code
 *	// Includes
 *	#include <FBase.h>
 *	#include <FText.h>
 *
 *	// Namespace
 *	using namespace Osp::Base;
 *	using namespace Osp::Text;
 *
 *	void
 *	MyClass::Utf8DecoderSample(void)
 *	{
 *		Utf8Decoder utf8De;
 *
 *
 *		// This method fills a %ByteBuffer with long strings to decode it into the unicode strings.
 *		ByteBuffer* pBB = PrepareUtf8DecoderSample(); 
 *
 *		int byteBufSize = pBB->GetCapacity();
 *		
 *		int charCount;
 *		utf8De.GetCharCount(*pBB, 0, byteBufSize, charCount);
 *
 *		McharBuffer deChars;
 *		deChars.Construct(charCount + 1);		// for L'\0'
 *
 *
 *		int byteIndex = 0;
 *		int byteCount = 100;
 *
 *		while (byteIndex < byteBufSize)
 *		{
 *			McharBuffer* pMB = null;
 *
 *			if (byteBufSize - byteIndex < byteCount)
 *				byteCount = byteBufSize - byteIndex;
 *
 *			// Converts Utf8 to Unicode using Utf8Decoder
 *			pMB = utf8De.GetCharsN(*pBB, byteIndex, byteCount);
 *
 *			deChars.CopyFrom(*pMB);
 *			byteIndex += byteCount;
 *
 *			delete pMB;
 *		}
 *
 *		deChars.Set(L'\0');
 *		deChars.Rewind();
 *
 *
 *		delete pBB;
 *
 *	}
 *	@endcode
 */


class _EXPORT_TEXT_ Utf8Decoder :
	public Decoder
{
// Lifecycle
public:
	/** 
	 * This is the default constructor for this class.
	 *
	 * @since	1.0
	 */
	Utf8Decoder(void);
	/** 
	 * This is the destructor for this class.
	 *
	 * @since	1.0
	 */
	virtual ~Utf8Decoder(void);

// Operations
public:
	/** 
	 * Calculates the total number of characters that are generated by decoding an instance of %ByteBuffer.
	 *
	 * @since			1.0
	 * @return		An error code
	 * @param[in]	bytes                   An instance of %ByteBuffer that is to be decoded
	 * @param[in] byteIndex                  The index from where decoding begins  
	 * @param[in] byteCount                 The total number of bytes to decode
	 * @param[out]  charCount               The total number of characters that are generated by decoding the specified %ByteBuffer instance
	 * @param[in]   flush                   Set to @c true to allow this instance to flush its state at the end of the conversion, @n
	 *						                else @c false
	 * @exception	E_SUCCESS				The method is successful.
	 * @exception	E_INVALID_ARG			A specified input parameter is invalid, or
     *                                      the specified @c bytes is empty.
	 * @exception	E_OUT_OF_RANGE			The value of an argument is outside the valid range defined by the method, or
     *                                      the length of the specified @c byteIndex or @c byteCount is greater than the length of the specified @c bytes.
	 * @exception	E_UNDERFLOW				This operation has caused the memory to underflow, or
	 *										the sum of the length of the specified @c byteIndex and @c byteCount is greater than the length of the specified @c bytes.
	 * @exception	E_INVALID_ENCODING_RANGE The conversion has failed due to invalid encoding range.
	 */
	virtual result GetCharCount(const Osp::Base::ByteBuffer& bytes, int byteIndex, int byteCount, int& charCount, bool flush = false);	

	/** 
	 *  Decodes an instance of %ByteBuffer into an instance of McharBuffer.
	 *
	 * @since			1.0
	 * @return		                       A pointer to the McharBuffer instance where the resultant decoded data is stored, @n
     *                                     else @c null if an exception occurs @n
	 *				                       The buffer limit is the position of the last decoded byte plus one and the starting position is zero.
	 * @param[in]	bytes                 An instance of %ByteBuffer that is to be decoded
	 * @param[in]   flush                 Set to @c true to allow this instance to flush its state at the end of the conversion, @n
	 *				                      else @c false
   * @exception	E_SUCCESS                The method is successful.
	 * @exception	E_OUT_OF_MEMORY       The memory is insufficient.
	 * @exception	E_INVALID_ARG            A specified input parameter is invalid, or
	 *                                         a specified @c bytes is empty.
	 * @exception	E_INVALID_ENCODING_RANGE The specified string contains code points that are outside the bounds of the character encoding scheme.
	 * @remarks		The specific error code can be accessed using the GetLastResult() method.
	 */
	virtual Osp::Base::McharBuffer* GetCharsN(const Osp::Base::ByteBuffer& bytes, bool flush = false);

	/** 
	 * Decodes an instance of %ByteBuffer into an instance of McharBuffer as per the specified range.
	 * 
	 * @since			1.0
	 * @return		                         A pointer to the McharBuffer instance where the resultant decoded data is stored, @n
     *                                       else @c null if an exception occurs @n
	 *				                         The buffer limit is the position of the last decoded byte and the starting position is zero.
	 * @param[in]	bytes                    An instance of %ByteBuffer that is to be decoded
	 * @param[in]   byteIndex                 The index from where decoding begins
	 * @param[in]   byteCount                The total number of bytes to decode
	 * @param[in]   flush                    Set to @c true to allow this instance to flush its state at the end of the conversion, @n
	 *				                         else @c false
	 * @exception	E_SUCCESS                The method is successful.
	 * @exception	E_OUT_OF_MEMORY          The memory is insufficient.
	 * @exception	E_INVALID_ARG            A specified input parameter is invalid, or
	 *                                       the specified @c bytes is empty.
	 * @exception	E_OUT_OF_RANGE	   		 The value of an argument is outside the valid range defined by the method, or
	 *									       the length of the specified @c byteIndex or @c byteCount is greater than the length of the specified @c bytes.
	 * @exception	E_UNDERFLOW	             This operation has caused the memory to underflow, or
	 *										  the sum of the length of the specified @c byteIndex and @c byteCount is greater than the length of the specified @c bytes. 
	 * @exception	E_INVALID_ENCODING_RANGE The specified string contains code points that are outside the bounds of the character encoding scheme.
	 * @remarks     The GetCharsN() method maintains state consistency between conversions. 	
	 * @remarks		The specific error code can be accessed using the GetLastResult() method.
	 * @remarks		The pointer to the %ByteBuffer instance is not terminated by a @c null character.
	 *
	 * 
	 */
	virtual Osp::Base::McharBuffer* GetCharsN(const Osp::Base::ByteBuffer& bytes, int byteIndex, int byteCount, 
		bool flush = false);

private:

	bool __flag;
	byte __byteLast;
	byte __byteBeforeLast;
	int __bytePrevCount;
	int __byteRemain;
	int __position;
	
	result GetPrevChars(const Osp::Base::ByteBuffer& bytes, mchar* pMcharPrev, int& byteStart, int& charPrevSize);

	bool ConvertUtf8ToUnicode(mchar* pMchar, int mcharBufSize, byte* pByte, int byteCount);
	int GetUtf8SizeInUnicode(byte* pByte, int byteCount, bool flush);

	bool DecodeUtf8ToMc(mchar *pmszOutText, int outBufSize, byte* szInText, int byteCount) const;


private:
	friend class Utf8DecoderEx;
	class Utf8DecoderEx* __pUtf8DecoderEx;
};


} }// Osp::Text
#endif//_FTEXT_UTF8_DECODER_H_


